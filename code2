# ================== COMPATIBLE CORRELATION TOOLKIT (Py 3.8/3.9) ==================
import numpy as np
import pandas as pd
from typing import Optional, Tuple, Dict

# ---- 1) DATA FETCH (kept like your code) ----
def get_spots_df(tickers, lookback='-20y'):
    """
    Fetch PX_LAST timeseries for the input tickers.
    Returns a DataFrame indexed by date with one column per ticker.
    """
    data = []
    blp = BLP()
    for tick in tickers:
        if 'Index' in tick:
            aux_df = blp.bdh([tick], ['PX_LAST'], startDate=lookback)
        else:
            aux_df = blp.bdh([tick], ['PX_LAST'], startDate=lookback,
                             adjustmentNormal=True, adjustmentAbnormal=True, adjustmentSplit=True)
        aux_df.columns = [tick]
        data.append(aux_df.copy(True))

    aggr_df = pd.concat(data, axis=1)
    aggr_df.columns = tickers
    return aggr_df

# ---- 2) CLASSIFICATION & TRANSFORMS ----
def log_returns(series: pd.Series) -> pd.Series:
    out = np.log(series).diff()
    out.name = f"{series.name}_logret"
    return out

def level_changes(series: pd.Series, to_bps: bool = True) -> pd.Series:
    """
    For rates series quoted in % (e.g., 4.25 for 4.25%), use *level changes*.
    If to_bps=True, convert percentage-point changes to basis points (×100).
    """
    out = series.diff()
    if to_bps:
        out = out * 100.0   # 0.05pp -> 5 bps; 1.00% move -> 100 bps
    out.name = f"{series.name}_dlevel"
    return out

def transform_by_asset_class(series: pd.Series, asset_class: str, rates_in_bps: bool = True) -> pd.Series:
    if asset_class in ("Equity", "FX", "Commodity"):
        return log_returns(series)
    elif asset_class == "Rates":
        return level_changes(series, to_bps=rates_in_bps)
    else:
        raise ValueError("Unknown asset class: %s" % asset_class)

def guess_asset_class(ticker: str) -> str:
    t = ticker.lower()
    if 'curncy' in t:
        # FX tickers like 'EURUSD Curncy', 'XAU Curncy'
        if any(k in t for k in ['xau', 'xag', 'xpt', 'xpd']):  # metals as commodities
            return 'Commodity'
        return 'FX'
    if 'cmdty' in t or 'comdty' in t:
        return 'Commodity'
    if any(k in t for k in ['ussw', 'usgg', 'govt', 'swap', 'rate', 'yld', 'yield']):
        return 'Rates'
    return 'Equity'

# ---- 3) CORRELATION CORE ----
def _prep_pair(df_prices: pd.DataFrame,
               a: str, b: str,
               classes: Optional[Dict[str, str]] = None,
               rates_in_bps: bool = True,
               winsorize: Optional[Tuple[float, float]] = (0.01, 0.99)) -> pd.DataFrame:
    """
    - Determine asset classes (from `classes` or via heuristics)
    - Apply transforms (log/log or log/dLevel)
    - Align, winsorize (optional), and return a 2-col DataFrame
    """
    if classes is None:
        classes = {}
    cls_a = classes.get(a, guess_asset_class(a))
    cls_b = classes.get(b, guess_asset_class(b))

    sub = df_prices[[a, b]].dropna().copy()
    ta = transform_by_asset_class(sub[a], cls_a, rates_in_bps=rates_in_bps)
    tb = transform_by_asset_class(sub[b], cls_b, rates_in_bps=rates_in_bps)

    X = pd.concat([ta, tb], axis=1).dropna()

    if winsorize is not None:
        lq, uq = winsorize
        Xa = X.iloc[:, 0]
        Xb = X.iloc[:, 1]
        X.iloc[:, 0] = Xa.clip(Xa.quantile(lq), Xa.quantile(uq))
        X.iloc[:, 1] = Xb.clip(Xb.quantile(lq), Xb.quantile(uq))
        X = X.dropna()

    return X

def unconditional_corr(df_prices: pd.DataFrame,
                       a: str, b: str,
                       classes: Optional[Dict[str, str]] = None,
                       rates_in_bps: bool = True,
                       winsorize: Optional[Tuple[float, float]] = (0.01, 0.99)) -> Dict[str, float]:
    """
    Full-sample Pearson correlation of the transformed pair.
    Returns: {'rho': r, 'n': N, 'rho_lo95': lo, 'rho_hi95': hi} (CI only if N>10).
    """
    X = _prep_pair(df_prices, a, b, classes, rates_in_bps, winsorize)
    r = float(X.iloc[:, 0].corr(X.iloc[:, 1]))
    n = int(len(X))
    out: Dict[str, float] = {"rho": r, "n": float(n)}

    if n > 10 and abs(r) < 0.9999:
        z = 0.5 * np.log((1 + r) / (1 - r))
        se = 1.0 / np.sqrt(n - 3)
        z_lo, z_hi = z - 1.96*se, z + 1.96*se
        r_lo = (np.exp(2*z_lo) - 1) / (np.exp(2*z_lo) + 1)
        r_hi = (np.exp(2*z_hi) - 1) / (np.exp(2*z_hi) + 1)
        out["rho_lo95"] = float(r_lo)
        out["rho_hi95"] = float(r_hi)
    return out

def rolling_corr(df_prices: pd.DataFrame,
                 a: str, b: str,
                 window: int = 126,
                 min_periods: Optional[int] = None,
                 classes: Optional[Dict[str, str]] = None,
                 rates_in_bps: bool = True,
                 winsorize: Optional[Tuple[float, float]] = (0.01, 0.99)) -> pd.Series:
    """
    Rolling Pearson correlation of the transformed pair.
    window: observations per window (126 ≈ 6m, 252 ≈ 1y).
    """
    if min_periods is None:
        min_periods = max(20, window // 3)
    X = _prep_pair(df_prices, a, b, classes, rates_in_bps, winsorize)
    rc = X.iloc[:, 0].rolling(window, min_periods=min_periods).corr(X.iloc[:, 1])
    rc.name = "rolling_corr_%s_%s" % (a.replace(' ', '_'), b.replace(' ', '_'))
    return rc

# ---- 4) SHORTCUT WRAPPERS ----
def corr_equity_fx(df_prices: pd.DataFrame, equity_tkr: str, fx_tkr: str, **kwargs) -> Dict[str, float]:
    classes = kwargs.pop("classes", {equity_tkr: "Equity", fx_tkr: "FX"})
    return unconditional_corr(df_prices, equity_tkr, fx_tkr, classes=classes, **kwargs)

def corr_equity_cmdty(df_prices: pd.DataFrame, equity_tkr: str, cmdty_tkr: str, **kwargs) -> Dict[str, float]:
    classes = kwargs.pop("classes", {equity_tkr: "Equity", cmdty_tkr: "Commodity"})
    return unconditional_corr(df_prices, equity_tkr, cmdty_tkr, classes=classes, **kwargs)

def corr_equity_rates(df_prices: pd.DataFrame, equity_tkr: str, rates_tkr: str, **kwargs) -> Dict[str, float]:
    classes = kwargs.pop("classes", {equity_tkr: "Equity", rates_tkr: "Rates"})
    return unconditional_corr(df_prices, equity_tkr, rates_tkr, classes=classes, **kwargs)
# ================================================================================
